import os
import json
import hashlib
from gtts import gTTS
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (Application, CommandHandler, MessageHandler,
                          ContextTypes, filters, CallbackQueryHandler)
from deep_translator import GoogleTranslator
from pypinyin import pinyin, Style
import openpyxl
from openpyxl.utils import get_column_letter
from telegram.ext import MessageHandler, filters
import eng_to_ipa as ipa

# ==== File c·∫•u h√¨nh ====
ADMIN_FILE = "admins.json"
DB_FILE = "translation_db.json"
TEMP_FILE = "temp_callback_data.json"


# ==== Qu·∫£n l√Ω Admin ====
def load_admins():
    try:
        with open(ADMIN_FILE, "r", encoding="utf-8") as f:
            return set(json.load(f))
    except:
        save_admins(set())
        return set()


def save_admins(admin_set):
    with open(ADMIN_FILE, "w", encoding="utf-8") as f:
        json.dump(list(admin_set), f, ensure_ascii=False, indent=2)


admins = load_admins()


def is_admin(user_id):
    return str(user_id) in admins


# ==== Qu·∫£n l√Ω Database ====
class TranslationDatabase:

    def __init__(self):
        self.data = {"history": [], "saved_phrases": {}}
        self.load_db()

    def load_db(self):
        try:
            with open(DB_FILE, "r", encoding="utf-8") as f:
                self.data = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.save_db()

    def save_db(self):
        with open(DB_FILE, "w", encoding="utf-8") as f:
            json.dump(self.data, f, ensure_ascii=False, indent=2)

    def save_phrase(self, user_id, phrase, translation):
        if str(user_id) not in self.data["saved_phrases"]:
            self.data["saved_phrases"][str(user_id)] = {}
        self.data["saved_phrases"][str(user_id)][phrase] = translation
        self.save_db()

    def delete_phrase(self, user_id, phrase):
        if str(user_id) in self.data["saved_phrases"]:
            if phrase in self.data["saved_phrases"][str(user_id)]:
                del self.data["saved_phrases"][str(user_id)][phrase]
                self.save_db()
                return True
        return False

    def search_phrases(self, user_id, keyword):
        if str(user_id) not in self.data["saved_phrases"]:
            return {}
        return {
            k: v
            for k, v in self.data["saved_phrases"][str(user_id)].items()
            if keyword.lower() in k.lower() or keyword.lower() in v.lower()
        }

    def add_history(self, user_id, original, translated, direction):
        self.data["history"].append({
            "user_id": str(user_id),
            "original": original,
            "translated": translated,
            "direction": direction,
            "timestamp": datetime.now().isoformat()
        })
        self.save_db()

    def get_user_history(self, user_id, limit=5):
        user_history = [
            item for item in self.data["history"]
            if item["user_id"] == str(user_id)
        ]
        return sorted(user_history, key=lambda x: x["timestamp"],
                      reverse=True)[:limit]


db = TranslationDatabase()

# ==== L∆∞u tr·ªØ callback_data t·∫°m b·ªÅn v·ªØng ====


def load_temp_data():
    try:
        with open(TEMP_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return {}


def save_temp_data(data):
    with open(TEMP_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


temp_data = load_temp_data()


# ==== H√†m h·ªó tr·ª£ t·∫°o ID ng·∫Øn t·ª´ text ====
def short_id(text):
    return hashlib.md5(text.encode()).hexdigest()[:10]


# ==== D·ªãch ng√¥n ng·ªØ & Phi√™n √¢m ====
async def translate_chunk(text):
    try:
        # N·∫øu ch·ª©a ti·∫øng Anh
        if any(char.isalpha()
               for char in text) and all(ord(c) < 128 for c in text):
            translated = GoogleTranslator(source='en',
                                          target='vi').translate(text)
            pronunciation = ipa.convert(text)  # <-- Th√™m d√≤ng n√†y
            return {
                "translation": translated,
                "direction": "en-vi",
                "pinyin":
                pronunciation  # S·ª≠ d·ª•ng tr∆∞·ªùng pinyin ƒë·ªÉ ch·ª©a phi√™n √¢m
            }

        # N·∫øu ch·ª©a ti·∫øng Vi·ªát
        vietnamese_chars = set(
            'ƒÉ√¢ƒë√™√¥∆°∆∞√°√†·∫£√£·∫°·∫•·∫ß·∫©·∫´·∫≠·∫Ø·∫±·∫≥·∫µ·∫∑√©√®·∫ª·∫Ω·∫π·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç·ªë·ªì·ªï·ªó·ªô·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµ'
        )
        if any(char in vietnamese_chars for char in text.lower()):
            translated = GoogleTranslator(source='vi',
                                          target='en').translate(text)
            pronunciation = ipa.convert(
                translated)  # Phi√™n √¢m cho k·∫øt qu·∫£ ti·∫øng Anh
            return {
                "translation": translated,
                "direction": "vi-en",
                "pinyin": pronunciation
            }

    except Exception as e:
        print(f"L·ªói khi d·ªãch: {e}")
    return None


async def detect_and_translate(text, user_id=None):
    result = await translate_chunk(text)
    if result and user_id:
        db.add_history(user_id, text, result["translation"],
                       result["direction"])
    return result


# ==== G·ª≠i k·∫øt qu·∫£ d·ªãch v·ªõi n√∫t l∆∞u (callback_data ƒë√£ l∆∞u v√†o file) ====
async def send_translation_with_save_button(update: Update,
                                            context: ContextTypes.DEFAULT_TYPE,
                                            text: str, result: dict):
    key = short_id(text)

    # L∆∞u d·ªØ li·ªáu t·∫°m ƒë·ªÉ x·ª≠ l√Ω sau (khi b·∫•m n√∫t)
    temp_data[key] = {
        "text": text,
        "translation": result["translation"],
        "direction": result["direction"]
    }
    save_temp_data(temp_data)

    # T·∫°o n√∫t "Nghe" v√† "L∆∞u t·ª´"
    keyboard = [[
        InlineKeyboardButton("üîä Nghe", callback_data=f"listen_{key}"),
        InlineKeyboardButton("üíæ L∆∞u t·ª´", callback_data=f"save_{key}")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # Hi·ªÉn th·ªã h∆∞·ªõng d·ªãch
    direction_map = {
        "en-vi": "üá¨üáß‚Üíüáªüá≥",
        "vi-en": "üáªüá≥‚Üíüá¨üáß",
        "zh-vi": "üá®üá≥‚Üíüáªüá≥",
        "vi-zh": "üáªüá≥‚Üíüá®üá≥"
    }

    response = f"{direction_map.get(result['direction'], '')}\nüî§ {result['translation']}\n"

    # N·∫øu c√≥ phi√™n √¢m th√¨ th√™m v√†o
    if result.get("pinyin"):
        response += f"üó£Ô∏è Phi√™n √¢m: {result['pinyin']}\n"

# G·ª≠i k·∫øt qu·∫£ + n√∫t
    await context.bot.send_message(chat_id=update.message.chat.id,
                                   text=response,
                                   reply_markup=reply_markup)


# ==== X·ª≠ l√Ω callback khi nh·∫•n n√∫t L∆∞u ====
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    key = query.data.split("_", 1)[1]
    user_id = query.from_user.id

    if query.data.startswith("save_"):
        info = temp_data.get(key)
        if not info:
            await query.edit_message_text("‚ùå Kh√¥ng t√¨m th·∫•y c·ª•m t·ª´ ƒë·ªÉ l∆∞u.")
            return

        db.save_phrase(user_id, info["text"], info["translation"])
        await query.edit_message_text(
            text=f"{query.message.text}\n\n‚úÖ ƒê√£ l∆∞u: '{info['text']}'")

    elif query.data.startswith("listen_"):
        info = temp_data.get(key)
        if not info:
            await query.answer("‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ƒë·ªÉ ph√°t.")
            return

        text_to_speak = info["text"]
        lang_code = "en" if info["direction"] in ["en-vi", "vi-en"
                                                  ] else "zh-CN"

        try:
            tts = gTTS(text=text_to_speak, lang=lang_code)
            audio_path = f"tts_{key}.mp3"
            tts.save(audio_path)
            await context.bot.send_audio(chat_id=query.message.chat.id,
                                         audio=open(audio_path, "rb"),
                                         title="üîä Ph√°t √¢m")
            os.remove(audio_path)
        except Exception as e:
            print(f"L·ªói TTS: {e}")
            await query.answer("‚ö†Ô∏è Kh√¥ng th·ªÉ ph√°t √¢m.")


# ==== X·ª≠ l√Ω l·ªánh t·ª´ ng∆∞·ªùi d√πng ====
async def handle_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    user_id = update.message.from_user.id

    if '@' in text:
        text = text.split('@')[0]

    elif text == '/mysaved':
        if not is_admin(user_id):
            await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn admin.")
            return

        phrases = db.data["saved_phrases"]
        if phrases:
            msg_lines = ["üìö T·∫•t c·∫£ c·ª•m t·ª´ ƒë√£ l∆∞u:"]
            for user_id_key, user_phrases in phrases.items():
                msg_lines.append(f"User {user_id_key}:")
                for phrase, translation in user_phrases.items():
                    msg_lines.append(f"{phrase} ‚Üí {translation}")
            msg = "\n".join(msg_lines)
            await update.message.reply_text(msg[:4000])
        else:
            await update.message.reply_text("‚ùå Ch∆∞a c√≥ c·ª•m t·ª´ n√†o ƒë∆∞·ª£c l∆∞u.")

    elif text == '/saved':
        phrases = db.data["saved_phrases"].get(str(user_id), {})
        if phrases:
            msg = "\n".join(f"‚Ä¢ {k} ‚Üí {v}" for k, v in phrases.items())
            await update.message.reply_text(f"üìö C·ª•m t·ª´ ƒë√£ l∆∞u:\n{msg[:4000]}")
        else:
            await update.message.reply_text("‚ùå B·∫°n ch∆∞a l∆∞u c·ª•m t·ª´ n√†o.")

    elif text.startswith('/save '):
        phrase = text[6:].strip()
        result = await detect_and_translate(phrase, user_id)
        if result:
            db.save_phrase(user_id, phrase, result["translation"])
            await update.message.reply_text(f"‚úÖ ƒê√£ l∆∞u: '{phrase}'")
        else:
            await update.message.reply_text("‚ö†Ô∏è Kh√¥ng th·ªÉ d·ªãch c·ª•m t·ª´ n√†y.")

    elif text.startswith('/delete '):
        phrase = text[8:].strip()
        if db.delete_phrase(user_id, phrase):
            await update.message.reply_text(f"‚úÖ ƒê√£ x√≥a: '{phrase}'")
        else:
            await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y c·ª•m t·ª´ n√†y.")

    elif text.startswith('/find '):
        keyword = text[6:].strip()
        results = db.search_phrases(user_id, keyword)
        if results:
            msg = "\n".join(f"‚Ä¢ {k} ‚Üí {v}" for k, v in results.items())
            await update.message.reply_text(
                f"üîç K·∫øt qu·∫£ t√¨m ki·∫øm:\n{msg[:4000]}")
        else:
            await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y c·ª•m t·ª´.")

    elif text == '/history':
        history = db.get_user_history(user_id)
        if history:
            msg = "\n".join(
                f"{i['original']} ‚Üí {i['translated']} ({i['direction']})"
                for i in history)
            await update.message.reply_text(f"üìú L·ªãch s·ª≠ d·ªãch:\n{msg[:4000]}")
        else:
            await update.message.reply_text("‚ùå Ch∆∞a c√≥ l·ªãch s·ª≠ d·ªãch.")

    elif text.startswith('/addadmin '):
        if not is_admin(user_id):
            await update.message.reply_text("‚ö†Ô∏è B·∫°n kh√¥ng c√≥ quy·ªÅn admin.")
            return
        new_admin = text.split()[1]
        admins.add(new_admin)
        save_admins(admins)
        await update.message.reply_text(f"‚úÖ ƒê√£ th√™m admin: {new_admin}")

    elif text.startswith('/removeadmin '):
        if not is_admin(user_id):
            await update.message.reply_text("‚ö†Ô∏è B·∫°n kh√¥ng c√≥ quy·ªÅn admin.")
            return
        target = text.split()[1]
        if target in admins:
            admins.remove(target)
            save_admins(admins)
            await update.message.reply_text(f"‚úÖ ƒê√£ x√≥a admin: {target}")
        else:
            await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y admin.")

    elif text.startswith('/fast'):
        if not is_admin(user_id):
            await update.message.reply_text("‚ö†Ô∏è B·∫°n kh√¥ng c√≥ quy·ªÅn admin.")
            return

        parts = text.split()
        filter_date = None
        if len(parts) > 1:
            try:
                filter_date = datetime.strptime(parts[1], "%Y-%m-%d").date()
            except ValueError:
                await update.message.reply_text(
                    "‚ùå Ng√†y kh√¥ng h·ª£p l·ªá. ƒê·ªãnh d·∫°ng ƒë√∫ng: /fast YYYY-MM-DD")
                return

        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "L·ªãch s·ª≠ d·ªãch"
        ws.append(["User ID", "T√™n nick", "Username", "Original", "Timestamp"])

        for item in db.data["history"]:
            try:
                item_time = datetime.fromisoformat(item["timestamp"])
                if filter_date and item_time.date() != filter_date:
                    continue

                item_user_id = int(item["user_id"])
                user = await context.bot.get_chat(item_user_id)
                full_name = user.full_name or "Kh√¥ng r√µ"
                username = f"@{user.username}" if user.username else "Kh√¥ng c√≥"
            except:
                full_name = "Kh√¥ng l·∫•y ƒë∆∞·ª£c"
                username = "Kh√¥ng l·∫•y ƒë∆∞·ª£c"

            ws.append([
                item["user_id"], full_name, username, item["original"],
                item["timestamp"]
            ])

        for col in ws.columns:
            max_len = max(len(str(cell.value)) for cell in col if cell.value)
            ws.column_dimensions[get_column_letter(
                col[0].column)].width = max_len + 2

        filename = "lich_su_dich.xlsx"
        wb.save(filename)
        await update.message.reply_document(open(filename, "rb"))
        os.remove(filename)

    elif text == '/secure':
        if not is_admin(user_id):
            await update.message.reply_text("‚ö†Ô∏è B·∫°n kh√¥ng c√≥ quy·ªÅn admin.")
            return
        db.data["history"] = []
        db.data["saved_phrases"] = {}
        db.save_db()
        await update.message.reply_text("‚úÖ ƒê√£ x√≥a to√†n b·ªô d·ªØ li·ªáu.")

    else:
        await update.message.reply_text(
            "‚ö†Ô∏è L·ªánh kh√¥ng h·ª£p l·ªá ho·∫∑c ch∆∞a h·ªó tr·ª£.")


# ==== X·ª≠ l√Ω tin nh·∫Øn vƒÉn b·∫£n ====
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    user_id = update.message.from_user.id

    if text.startswith('/'):
        return

    result = await detect_and_translate(text, user_id)
    if result:
        await send_translation_with_save_button(update, context, text, result)
    else:
        await update.message.reply_text("üîç Kh√¥ng th·ªÉ nh·∫≠n di·ªán ng√¥n ng·ªØ.")


# ==== L·ªánh /start ====
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üåç English-Vietnamese Translator Bot\n\n"
        "üìå C√°ch d√πng:\n"
        "- G·ª≠i vƒÉn b·∫£n ti·∫øng Vi·ªát/Trung ƒë·ªÉ t·ª± ƒë·ªông d·ªãch.\n"
        "- Nh·∫•n n√∫t 'L∆∞u' ƒê·ªÉ l∆∞u c·ª•m t·ª´.\n"
        "- /save <c·ª•m t·ª´>: L∆∞u th·ªß c√¥ng.\n"
        "- /saved: Xem c√°c c·ª•m t·ª´ ƒë√£ l∆∞u.\n"
        "- /delete <c·ª•m t·ª´>: X√≥a c·ª•m t·ª´ ƒë√£ l∆∞u.\n"
        "- /find <t·ª´ kh√≥a>: T√¨m c·ª•m t·ª´ ƒë√£ l∆∞u.\n"
        "- /history: Xem l·ªãch s·ª≠ d·ªãch.\n\n"
        "üëâ @xukaxuka2k1 code free,fastandsecureüëà")


async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id

    # Ki·ªÉm tra quy·ªÅn admin
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn.")

    admin_commands = ("üìú **ADMIN MENU** üìú\n\n"
                      "üîπ /fast - ...\n"
                      "üîπ /secure - ...\n"
                      "üîπ /delete - L√†m m·ªõi l·∫°i to√†n b·ªô.\n"
                      "üîπ /addadmin - ID L√†m admin.\n"
                      "üîπ /removeadmin - ID Xo√° admin.")

    await update.message.reply_text(admin_commands, parse_mode="Markdown")


async def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "‚ùì L·ªánh kh√¥ng h·ª£p l·ªá. G√µ /start ƒë·ªÉ xem l·ªánh.\n\n"
        "üéÆ game Caro:\u2003\u2003@Game_carobot\n"
        "üéÆ N·ªëi ch·ªØ:\u2003\u2003\u2003@noi_chu_bot\n"
        "üÄÑ Google :\u2003\u2003@Dichngon_ngubot")


# ==== Kh·ªüi ch·∫°y Bot ====
def main():
    TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    if not TOKEN:
        print("‚ùå Ch∆∞a thi·∫øt l·∫≠p TELEGRAM_BOT_TOKEN")
        return

    app = Application.builder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("admin", admin_command))
    app.add_handler(
        CommandHandler([
            "saved", "mysaved", "save", "delete", "find", "history",
            "addadmin", "removeadmin", "fast", "secure"
        ], handle_command))
    app.add_handler(CallbackQueryHandler(button_callback))
    app.add_handler(MessageHandler(filters.COMMAND, unknown))
    app.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    print("ü§ñ Bot ƒë√£ kh·ªüi ƒë·ªông...")
    app.run_polling()


if __name__ == '__main__':
    main()
